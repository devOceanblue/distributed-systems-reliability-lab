# B-0342 — Experiment E-019: MySQL Deadlock/Lock Contention 재현 + retry/backoff/DLQ 정책 검증

## Goal
MySQL(InnoDB)에서 동시에 같은 자원을 업데이트하면
- Deadlock(ER_LOCK_DEADLOCK 1213)
- Lock wait timeout(1205)
이 실제로 자주 발생한다.

이 실험은:
1) deadlock을 "의도적으로" 만들고
2) consumer가 이를 transient로 처리하여 retry로 회복하는지
3) 잘못 설계하면 DLQ 폭증/처리 정체로 이어지는지
를 재현한다.

---

## Background
- Deadlock은 장애가 아니라 "동시성에서 정상적으로 발생하는 상황"이다.
- 중요한 것은:
  - 락 획득 순서를 일관되게 만들거나(예방)
  - deadlock을 transient로 보고 retry/backoff로 회복(운영 표준)
- processed_event는 중복 side-effect를 막지만,
  - deadlock retry 시 "DB 작업이 일부 수행되고 롤백"될 수 있으므로
  - 트랜잭션 경계가 중요하다(INSERT processed_event + update projection을 같은 tx로)

---

## Scope
### 1) consumer-service에 deadlock 유발 모드 추가
- ENV:
  - DEADLOCK_INDUCER=ON/OFF
  - DEADLOCK_HOLD_MS=200 (락 잡고 버티기)
- 방법(의도적으로 교착 만들기):
  - 두 테이블(row)을 서로 다른 순서로 락 잡도록 분기
  - 예:
    - Thread A: lock account_projection(A-1) -> lock account_projection(A-2)
    - Thread B: lock account_projection(A-2) -> lock account_projection(A-1)
  - 구현은 DB에서:
    - `SELECT ... FOR UPDATE`로 row lock을 잡고 sleep(DEADLOCK_HOLD_MS)
- 이벤트 설계:
  - 하나의 이벤트가 두 계정 row를 업데이트하도록 “transfer” 타입을 추가하거나,
  - 테스트 전용으로 consumer가 특정 event_type에서 2개 row를 잠그게 해도 됨.

### 2) 오류 분류/재시도 정책 검증
- Deadlock(1213), Lock wait timeout(1205)은 transient로 분류
- 처리:
  - retry topic으로 재발행(attempt++)
  - backoff(5s → 1m 등)
- 잘못된 정책(실패 케이스):
  - deadlock을 permanent로 분류 → DLQ 폭증
  - 또는 재시도 없이 throw → 컨슈머 정체/무한 재시작

### 3) 관측 포인트
- mysql exporter: lock waits / deadlocks (가능하면)
- consumer error rate 증가
- retry topic 유입 증가
- DLQ 증가(실패 정책에서)
- `SHOW ENGINE INNODB STATUS`에서 deadlock trace 확인(런북에 절차 포함)

---

## Experiment Steps
### E-019-A (Failure) — deadlock을 permanent로 처리하여 DLQ 폭증
1) Setup
- DEADLOCK_INDUCER=ON
- consumer 오류 분류:
  - deadlock을 permanent로 처리 (또는 FAILPOINT_CLASSIFY_DEADLOCK_AS_PERMANENT=true)
- 입력 트래픽:
  - transfer 이벤트를 500건 이상 빠르게 발행(동시성 필요)
  - consumer concurrency=2 이상

2) Run
- consumer 실행 후 1~3분

3) Assert
- DLQ rate 증가
- projection 반영률 저하
- (가능하면) deadlock 오류 로그 다수

### E-019-B (Success) — deadlock transient retry로 회복
1) Setup
- 동일하게 DEADLOCK_INDUCER=ON
- 분류:
  - deadlock/lock timeout은 retry로
- retry 토픽 단계(5s, 1m) 동작 확인

2) Run 동일 부하
3) Assert
- DLQ 증가가 미미(0 또는 낮음)
- 최종적으로 projection이 expected 결과로 수렴
- retry topic에서 재처리 후 성공이 확인됨(attempt>0인 메시지 존재)

### E-019-C (Prevention Variant) — 락 획득 순서 일관화로 deadlock 감소(선택)
- 락을 항상 account_id 오름차순으로 잡기
- Assert: deadlock 발생률이 크게 줄어듦

---

## Deliverables
- 신규 이벤트(선택):
  - `AccountTransferRequested` (from, to, amount, txId)
  - consumer가 2 row를 업데이트하며 deadlock 유발/예방 실험
- consumer-service 코드:
  - deadlock inducer(SELECT FOR UPDATE + sleep)
  - error classifier:
    - 1213/1205 -> transient retry
- docs:
  - `experiments/E-019-mysql-deadlock.md`
- scripts:
  - `scripts/exp run E-019`
  - `scripts/assert/E-019.sh`:
    - DLQ 카운트 비교(fail vs success)
    - projection 결과 수렴 확인
    - 로그에서 1213/1205 카운트 확인
- Runbook:
  - "deadlock 분석(innodb status) + retry 전략" 추가

---

## Acceptance Criteria
- deadlock이 의도적으로 100% 재현된다(적어도 failure 세팅에서).
- transient retry 정책에서 DLQ 폭증 없이 최종 상태가 수렴한다.
- prevention variant 적용 시 deadlock 발생률이 유의미하게 감소한다(선택).

# B-0346 — Experiment E-023: Partial Outage Degradation 실험 (Redis/Kafka/MySQL 장애 시 우아한 저하 vs 연쇄 장애)

## Goal
실제 운영 장애는 "한 구성요소만" 죽는 경우가 많다.
그때 시스템이:
- 무너질 것인가(연쇄 장애) vs
- 기능을 줄이더라도 살아남을 것인가(우아한 저하)
가 시스템 성숙도를 가른다.

이 실험은 Redis/Kafka/MySQL 각각 장애를 주입해:
1) 잘못된 설계에서 연쇄 장애가 나는 실패 케이스
2) circuit breaker/timeout/bulkhead + fallback(스테일 허용/쓰기 차단)으로 생존하는 성공 케이스
를 재현한다.

---

## Background: Degradation 패턴
- Timeout: 외부 호출을 오래 붙잡지 말 것
- Circuit breaker: 실패가 연속되면 빠르게 차단
- Bulkhead: 자원(스레드/커넥션)을 격리
- Fallback:
  - Redis 실패 -> DB fallback(단, stampede 방어)
  - Kafka 실패 -> write 차단 또는 outbox backlog만 적재 후 나중에 릴레이
  - MySQL 실패 -> read-only 모드/쓰기 차단(무한 재시도 금지)

---

## Scope
### A) Query path (Redis 장애)
#### Failure variant
- query-service:
  - timeout 없음/길게
  - stampede protection OFF
  - circuit breaker OFF
- Redis 다운/지연 시:
  - 모든 요청이 DB로 몰려 DB overload 유발

#### Success variant
- query-service:
  - redis timeout 짧게(예: 50~100ms)
  - circuit breaker ON (Resilience4j 권장)
  - stampede protection ON (singleflight)
  - fallback policy:
    - (옵션1) DB fallback + rate limit
    - (옵션2) "stale serve": 마지막 캐시값이 있으면 TTL 지나도 제한적으로 제공(soft TTL)
- 기대:
  - Redis 장애에도 DB 폭발을 완화하고 p99를 안정화

### B) Write path (Kafka 장애)
Kafka가 느리거나 down일 때 커맨드 처리 전략:
#### Failure variant
- command-service direct-produce 모드 + Kafka down
- 기대:
  - 요청 지연/timeout/재시도 폭증
  - 일부 DB 반영/일부 실패로 불일치 가능

#### Success variant (운영 표준)
- command-service outbox-only:
  - 요청 시 DB tx로 domain+outbox만 기록하고 빠르게 성공 반환
  - relay가 Kafka 복구 후 backlog 전송
- 추가 보호:
  - outbox backlog oldest age가 임계치 이상이면 "write 차단"(503) 또는 "속도 제한"
- 기대:
  - Kafka 장애 동안에도 쓰기 경로가 DB에만 안전하게 적재되며, 복구 후 회복

### C) DB 장애(MySQL)
#### Failure variant
- 무한 재시도/긴 타임아웃으로 스레드/커넥션 고갈(연쇄 장애)

#### Success variant
- DB timeout 짧게 + circuit breaker
- write 요청은 즉시 실패(503)로 차단(큐잉 금지)
- read는 (옵션) stale cache serve로 일정 수준 유지

---

## Implementation Requirements
1) Resilience4j 적용(권장)
- query-service:
  - redis 호출에 circuit breaker + timeout + bulkhead
- command-service:
  - kafka produce(직접 모드) 또는 relay publish에 timeout/cb
- consumer-service:
  - db write에 timeout + deadlock retry는 별도로 유지

2) Degradation toggles (ENV)
- DEGRADE_MODE:
  - off
  - safe (cb/timeout/fallback on)
  - unsafe (cb/timeout/fallback off)
- STALE_SERVE_MODE:
  - off
  - soft_ttl (stale 허용)

3) Chaos scripts 연동
- Redis down/up
- Kafka broker down/up(또는 네트워크 지연)
- MySQL down/up(또는 connection limit 낮추기)

---

## Experiment Design
### E-023-1 Redis partial outage
1) Setup
- 부하: k6 500 rps, 60s
- unsafe mode로 실행
2) chaos: redis stop
3) assert:
- DB QPS/conn 폭증, latency 급증/5xx
4) safe mode로 반복:
- db 폭증 완화, latency 악화 폭 줄어듦

### E-023-2 Kafka partial outage
1) command-service:
- failure: PRODUCE_MODE=direct + kafka stop
- expect: timeout/오류 + 불일치 가능
2) success: PRODUCE_MODE=outbox + relay는 재시도
- kafka stop 동안에도 command는 성공, outbox backlog 증가
- kafka 복구 후 backlog 소거
- (옵션) backlog age 임계치 초과 시 write 차단 동작 확인

### E-023-3 MySQL partial outage
1) mysql stop 또는 connection 제한/지연 주입
2) unsafe: 요청이 매달리며 스레드 고갈/오류 폭증
3) safe: 빠르게 실패 + circuit breaker open → 시스템 전체 생존
4) read는 stale serve로 일정 수준 유지(옵션)

---

## Deliverables
- code:
  - resilience4j 설정(각 서비스)
  - fallback/stale serve 구현(query-service)
  - write 차단(outbox backlog age 기반) 구현(command-service)
- scripts:
  - `scripts/exp run E-023`
  - `scripts/chaos/*` 사용
  - `scripts/assert/E-023.sh`:
    - unsafe vs safe 비교(오류율/latency/DB qps/outbox backlog)
- docs:
  - `experiments/E-023-degradation-partial-outage.md`
- Runbook:
  - Redis/Kafka/MySQL 장애별 대응(모드 전환/차단 기준/복구 절차)

---

## Acceptance Criteria
- unsafe 모드에서 부분 장애가 연쇄 장애로 확대되는 것이 재현된다.
- safe 모드에서 기능은 일부 저하되지만 시스템이 안정적으로 유지된다.
- Kafka 장애 시 outbox-only 패턴이 왜 강력한지 수치로 증명된다.

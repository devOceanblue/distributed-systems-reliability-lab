# B-0357 — Experiment E-024: Redis vs MySQL 선착순 쿠폰 동시성 발급 병목 비교

## Goal
선착순 쿠폰 발급에서 아래 3가지를 동시에 만족하는 구현을 비교/검증한다.
1) 정확히 `N`장만 발급(초과 발급 0)
2) 동일 유저 중복 발급 0
3) 단시간 폭주 트래픽(30k~100k+)에서 처리량/지연/병목 측정

MySQL 게이트와 Redis 게이트를 같은 부하로 비교해, 병목의 본질(단일 row 경합 vs 메모리 원자 게이트)을 실험으로 증명한다.

## Background
- 선착순 핵심은 “슬롯 확보”의 원자성이다.
- MySQL은 정확성을 위해 master read/write로 몰릴 수밖에 없어 핫스팟 row 경합이 발생한다.
- Redis는 Lua 원자 스크립트로 슬롯 확보를 DB 앞단에서 처리해 DB를 보호한다.

## Scope
### A) MySQL Gate Variant
- `UPDATE ... WHERE issued_count < total_quota` 형태의 원자적 슬롯 확보
- 성공 시에만 쿠폰 INSERT
- 중복 방지: `(promotion_id, user_id)` unique 제약
- master DB 경로만 사용(정확성 보장 모드)

### B) Redis Gate Variant
- Lua script로 원자 게이트 수행:
  - keys: `promo:{promoCode}:issued_count`, `promo:{promoCode}:users`
  - return: `1=success`, `0=soldout`, `-1=already-issued`
- Redis 성공 후 DB 저장(기본 sync, 옵션 async)
- Redis Cluster 고려: hash tag 고정(`{promoCode}`)

### C) Load Matrix
- Case 1: `30,000` 동시 요청
- Case 2: `100,000` 동시 요청(또는 repo 환경에서 재현 가능한 상한)
- 각 케이스에서 MySQL/Redis 각각 실행

### D) Deterministic Assertions
- 성공 수 == quota
- 초과 발급 수 == 0
- 중복 발급 수 == 0
- 총 소요시간, p95/p99 latency, 실패율 비교
- MySQL lock wait/deadlock/QPS, Redis command latency/hit ratio 관측

## Critical Checks
- Redis 테스트 초기화 키 불일치 방지:
  - 반드시 `promo:{promoCode}:issued_count` + `promo:{promoCode}:users` 함께 초기화
  - `promo:{promoCode}:count` 같은 오타 키 사용 시 assert fail

## Deliverables
- `experiments/E-024-coupon-concurrency-redis-vs-mysql.md`
- `infra/k6/coupon-issue.js` (또는 동등한 부하 스크립트)
- `scripts/scenarios/E-024.sh`
- `scripts/assert/E-024.sh`
- `scripts/verify/B-0357.sh`
- Runbook 업데이트:
  - “선착순 쿠폰 동시성 운영 가이드(MySQL vs Redis 선택 기준)”

## Acceptance Criteria
- 동일 quota에서 MySQL/Redis 모두 정확성(초과/중복 0) 만족
- 30k 구간에서 성능 차이 수치화(예: 총 시간, p95/p99)
- 100k(또는 상한 부하) 구간에서 MySQL 병목(락 대기/지연 상승) 재현
- Redis 게이트가 DB 부하 완화에 유의미함을 지표로 증명
- 실험 run/assert가 100% 결정론적으로 재현됨

# B-0336 — Experiment E-013: Redis Lua 원자 갱신(Atomic) 오남용으로 일관성 깨짐 재현 + 올바른 경계 제시

## Goal
Redis Lua는 "Redis 내부에서만" 원자적이다.
DB 트랜잭션과 함께 사용하면, 잘못된 순서/장애 시 "캐시가 정답처럼 보이지만 DB와 불일치"가 발생할 수 있다.
이를 실패/성공 케이스로 실험 재현하고, 올바른 사용 경계를 문서화한다.

## Background
- Lua는 Redis key/value 업데이트를 하나의 원자 연산으로 묶어 RTT를 줄이는 데 유용.
- 그러나 Redis는 정답 저장소가 아니며, DB commit과 결합된 "전역 원자성"을 제공하지 못한다.
- 잘못 쓰면:
  - DB는 롤백되었는데 Redis는 반영됨(유령 캐시)
  - DB는 반영되었는데 Redis는 갱신 실패(스테일)
  - Lua 업데이트 후 crash로 인해 invalidation 이벤트가 안 나가 stale 고착

## Scope
### 서비스/엔드포인트
- query-service 또는 별도 `cache-writer-service` 추가(선택)
- Endpoint:
  - POST /cache/atomic/incr
    - { "accountId": "A-1", "delta": 100 }
    - 내부에서 Lua로 `balance:{accountId}` INCRBY 수행

### 실패 케이스 A: "Redis 먼저 업데이트" + DB 실패(rollback)
- Flow:
  1) Lua로 캐시 INCR
  2) DB update 시도
  3) failpoint로 DB 트랜잭션 실패/롤백 유도
- 기대:
  - Redis는 증가했는데 DB는 증가하지 않음 -> 조회 결과가 틀림(stale/ghost)

### 실패 케이스 B: "DB 먼저 커밋" + Redis 갱신 실패
- Flow:
  1) DB commit
  2) Lua로 캐시 갱신
  3) failpoint로 Redis timeout/exception 유도
- 기대:
  - DB는 최신인데 캐시는 오래됨 -> stale 발생(하지만 TTL/invalidation로 결국 회복 가능)

### 성공 케이스: Redis를 "정답"으로 갱신하지 않고 invalidation만 사용
- Flow:
  1) DB commit
  2) outbox 이벤트로 "DEL(or version bump)" invalidation
  3) cache-aside로 다음 read에 DB로부터 재채움
- 기대:
  - 실패/재시도/순서 역전에도 잘못된 값이 캐시에 고착될 가능성이 낮음

## Implementation Details
- Lua 스크립트 파일: `infra/redis/lua/incr_balance.lua`
- failpoints:
  - FAILPOINT_AFTER_REDIS_LUA_BEFORE_DB=true
  - FAILPOINT_AFTER_DB_COMMIT_BEFORE_REDIS=true
  - FAILPOINT_FORCE_DB_ROLLBACK=true
  - FAILPOINT_FORCE_REDIS_TIMEOUT=true
- 검증 쿼리:
  - MySQL: account_projection.balance
  - Redis: GET balance:{id}
  - 서비스 응답값 비교

## Deliverables
- `experiments/E-013-redis-lua-consistency.md`
- `scripts/exp run E-013`, `scripts/assert/E-013.sh`, `scripts/exp cleanup E-013`
- Runbook.md에 "Redis Lua는 DB와 전역 원자성 없음" 섹션 추가
- (선택) Redis cluster에서도 동일 실험 가능하게 키/해시태그 대응

## Acceptance Criteria
- 실패 케이스 A에서 Redis/DB 불일치가 100% 재현
- 성공 케이스에서 동일 장애 주입에도 캐시가 TTL/invalidation로 정상 수렴함을 증명

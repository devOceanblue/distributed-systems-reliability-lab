# B-0345 — Experiment E-022: Backfill(대량 리플레이) 통제(샤딩/배치/체크포인트/스냅샷) vs 무통제 backfill로 장애 재현

## Goal
운영에서 가장 위험한 작업 중 하나가 "대량 backfill/replay"이다.
무통제로 하면:
- consumer lag 폭발
- DB QPS/락/데드락 폭발
- 캐시 invalidation 폭탄
- 정합성 오류(부분 처리/중복/순서)
가 발생한다.

이 실험은:
1) 무통제 backfill로 장애를 재현하고
2) 통제된 backfill(샤딩/배치/체크포인트/카나리/정합성 검증)로 안전 수행
을 증명한다.

---

## Background
- Replay는 중복을 동반: dedup_key/processed_event 없으면 데이터 사고
- Backfill은 "규모" 때문에 시스템 자원을 소모: rate limit/backpressure 필수
- 중단/재개가 가능해야 운영자가 안전하게 수행
- 가능한 경우 스냅샷(bootstrap) 후 delta만 backfill이 최적

---

## Scope
### A) backfill-worker 신규 또는 replay-worker 확장
- 기존 replay-worker를 확장해 "Backfill Mode"를 추가하거나,
  `services/backfill-worker`로 분리해도 됨.

필수 기능:
1) 범위 지정
- time window(occurred_at)
- account_id shard (hash mod N, shard_index)
- event_type filter

2) batch + rate limit + backpressure
- BATCH_SIZE(예: 100)
- RATE_LIMIT(msg/s)
- backpressure:
  - consumer lag > threshold
  - mysql connections/QPS > threshold
  - outbox oldest age > threshold
  - p99 latency > threshold
→ 자동 slow down/pause

3) 체크포인트(중단/재개)
- 체크포인트 저장(예: dlq/backfill source partition offset, last_processed_occurred_at 등)
- resume 가능
- 체크포인트는 (job_id, shard_index) 단위로 관리

4) canary backfill
- CANARY_COUNT=1000 또는 CANARY_DURATION=5m
- canary 후 자동 stop
- 운영자가 지표 보고 본작업 진행

5) audit
- backfill_job 테이블:
  - job_id, operator, mode, filters, shard_count, shard_index, rate, batch
  - started_at, ended_at, status, processed_count, error_count
- 각 메시지 header에 `backfill_id` 추가

6) 정합성 검증(필수)
- 샘플링 검증:
  - N개 account를 랜덤 선택해
  - domain(ledger) 합계와 projection(balance)의 합계가 맞는지 비교
- 또는 projection checksum:
  - (선택) account_projection 전체 합/해시를 기록

### B) Backfill Source
Backfill 데이터를 어디서 가져올지 2가지 중 택1(최소 1개 구현):
1) Kafka "replay source topic" (권장)
- `account.balance.replay-source` 같은 토픽에 과거 이벤트를 적재해두고 worker가 이를 읽어 main으로 재발행
- 또는 DLQ에서 직접 backfill (E-020과 연결)

2) MySQL ledger 기반 재생성
- ledger에서 이벤트를 재구성하여 Kafka로 발행 (단, 정렬/샤딩/배치 중요)

### C) 무통제 backfill 모드(실패 케이스)
- BACKFILL_MODE=unsafe:
  - no filter
  - no rate limit
  - no backpressure
  - no checkpoint
- 가능한 최대 속도로 main에 밀어넣기

---

## Experiment Design
### E-022-A (Failure): 무통제 backfill로 장애 재현
1) Setup
- 100k~1M 규모의 backfill 소스 준비(스크립트로 생성)
- consumer-service 정상(멱등 ON)이어도 자원 폭발은 발생 가능

2) Run
- BACKFILL_MODE=unsafe로 실행

3) Observe/Assert
- DB:
  - QPS/conn 폭증, deadlock/lock wait 가능
- Kafka:
  - lag 증가, 처리 정체/불안정
- Cache:
  - invalidation 폭증 → miss 증가
- 서비스:
  - p95/p99 latency 상승, 오류율 증가 가능
- assert는 최소:
  - DB connections/QPS 상승을 확인
  - consumer lag 또는 처리율 급락 확인
  - Runbook에 증거(스크린샷/수치) 남김

### E-022-B (Success): 통제된 backfill로 안전 수행
1) Setup
- BACKFILL_MODE=safe
- shard_count=8, shard_index=0..7 (각 shard를 별도 실행하거나 순차 실행)
- canary 1000건 후 stop → 지표 확인
- rate limit 200 msg/s부터 시작 + backpressure thresholds 설정

2) Run
- shard별 순차/병렬 실행(운영 표준처럼)
- 중간에 stop/resume 테스트(체크포인트)

3) Assert
- 지표 폭발 없이 점진적으로 backfill이 진행됨
- 최종 정합성 검증 통과(샘플링)
- audit/backfill_job 기록이 남음
- resume가 정확히 이어서 수행됨

### E-022-C (Snapshot Variant) (선택)
- projection을 DB snapshot으로 부트스트랩(대량) 후,
- delta 이벤트만 backfill
- assert:
  - 소요 시간/부하가 줄어듦

---

## Deliverables
- worker:
  - backfill safe/unsafe 모드 구현
  - shard/batch/rate/backpressure/checkpoint/canary/audit/validation
- db:
  - backfill_job / backfill_checkpoint 테이블(Flyway)
- docs:
  - `experiments/E-022-backfill-controlled.md`
- scripts:
  - `scripts/exp run E-022`
  - `scripts/assert/E-022.sh` (safe vs unsafe 비교)
  - `scripts/data/gen-backfill.sh` (소스 데이터 생성)

---

## Acceptance Criteria
- unsafe backfill이 자원 폭발/지표 악화를 재현한다.
- safe backfill이 동일 규모를 안정적으로 처리하며 중단/재개가 가능하다.
- 정합성 검증(샘플링)이 자동으로 통과한다.
